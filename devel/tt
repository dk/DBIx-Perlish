#! /usr/bin/perl
use strict;
use warnings;
use lib qw(lib);
use DBIx::Perlish;
$DBIx::Perlish::Parse::DEVEL = 1;

sub s1 {
	my $x : product_tree;
	$x->circuit_number =~ /^FB-/;
	$x->id == product_eda_adsl->id;
};

my $val = "god";
sub s2 {
	users->type eq $val,
	users->id == superusers->user_id;
};

my $from = 0;  my $to = 30;
sub s3 {
	my $t : ttt;
	last unless 3..($from*$to);
};

sub s4 {
	my $u : users;
	$u->id / 2 == 21;
	return ($u->name, blah => $u->id);
}

sub funcall {
	my $u : users;
	lower($u->name) eq "hehe";
	return ($u->name, blah => $u->id);
}

sub loneterm1 {
	my $u : users;
	$u->boolvar;
}

sub loneterm2 {
	my $u : users;
	!$u->boolvar;
}

sub loneterm3 {
	my $u : users;
	is_digit($u->id);
}

sub funcall2 {
	my $u : users;
	longfunc($u->name eq "hehe", !$u->boolvar);
}

sub funcall3 {
	my $u : users;
	longfunc($u->name eq "hehe", !$u->boolvar) == 42;
}

sub funcall4 {
	my $u : users;
	lc $u->name eq "hehe";
}

sub outer_ref {
	my $g : groups;
	$g->id <- db_fetch {
		my $u : users;
		$g->name eq $u->gname;
		return ($u->gid);
	};
}

sub outer_ref_exists {
	my $g : groups;
	db_fetch {
		my $u : users;
		$g->name eq $u->gname;
	};
}

sub labels {
	my $u : users;
	order_by: $u->name;
};

sub labels2 {
	my $u : users;
	order_by: $u->lastname, $u->firstname;
};

sub labels3 {
	my $u : users;
	LIMIT: 5;
};

my $off = 42;
sub labels4 {
	my $u : users;
	OFFSET: $off;
};

sub retall {
	my $t1 : table1;
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};

my $vart = 'table1';
my $self = { table => 'table1', id => 42, col => 'col1',
	h1 => { h2 => { h3 => 42 }},
};
my %self = ( table => 'table1', id => 42, col => 'col1',
	h1 => { h2 => { h3 => 42 }},
);
sub vartable {
	table: my $t1 = $vart;
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};
sub vartable1 {
	table: my $t1 = $self{table};
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};
sub vartable2 {
	table: my $t1 = $self->{table};
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};

sub hashref1 {
	my $t : table1;
	$t->id == $self->{id};
};
sub hashref2 {
	my $t : table1;
	$t->id == $self{id};
};
sub hashref3 {
	my $t : table1;
	$t->id == $self{h1}{h2}{h3};
};

sub funnytable {
	my $t : table = $self->{table};
};

sub shouldfail {
	table: $vart = 52;
};

my $type = "hello"; $type = "";
sub parsetime_if {
	my $t : product;
	$t->name eq $type if $type;
};

my $id = 42;
sub return_expr {
	my $p : product_tree;
	my $e : product_eda_adsl;
	$p->id == $id;
	$p->id == $e->id;

	return (
		$p->id,
		$p->circuit_number,
		$e,
		DAYS_TO_ACTIVATION => $e->ACTIVATION_DATE_START-sysdate(),
		TNIDInstallDate => abs($e->selt_date),
	);
};

sub funcall_no_args { tab->id == sysdate() };

sub verbatim {
	tab->id == sql "some_seq.nextval";
};

sub verbatim2 {
	tab->id == `some_seq.nextval`;
};

sub ret_concat {
	return "foo-" . tab->name . "-moo";
};

sub interp {
	my $t : tab;
	return "foo-$t->name-moo";
};

sub funny_interp {
	my $t : tab;
	return "foo-" . $t->firstname . " $t->lastname-moo";
};

sub interp_ashash {
	my $t : tab;
	return "abc$t->{name}xyz";
};

sub null1 {
	!defined(tab->field);
};

my @ary = (1,2,3);
my $ary = [1,2,3];
sub is1 {
	!tab->id  <-  @$ary;
};

# does not work
sub is2 {
	!tab->id  <-  map { $_*2 } @ary;
};

my $two = 2;
sub is3 {
	!tab->id  <-  [1,$two,3];
};

sub autogroup {
	my $t : tab;
	return $t->name, $t->type, count($t->age);
};

my $x = undef;
sub null_comp {
	tab->age != $x;
};

sub re22 {
	tab->str =~ /^$self->{id}/;
};

sub jj {
	my $t : tbl;
	db_fetch { $t->id == t2->some_id };
};

my $col = 'blah';
sub varcol {
	tbl->$col == 42;
};

sub bad1 {
	$self = { x => 1, y => 2};
};

sub re_in {
	tbl->id =~ /^$col/;
};

my ($sql, $v) = DBIx::Perlish::gen_sql(\&hashref3, "select");
print "$sql\n";
print "values: ", join ", ", @$v;
print "\n";
