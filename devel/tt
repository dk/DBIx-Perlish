#! /usr/bin/perl
use strict;
use warnings;
use lib qw(lib);
use DBIx::Perlish;
$DBIx::Perlish::Parse::DEVEL = 1;

sub s1 {
	my $x : product_tree;
	$x->circuit_number =~ /^FB_%/;
	$x->id == product_eda_adsl->id;
};

my $val = "god";
sub s2 {
	users->type eq $val,
	users->id == superusers->user_id;
};

my $from = 0;  my $to = 30;
sub s3 {
	my $t : ttt;
	last unless 3..($from*$to);
};

sub s4 {
	my $u : users;
	$u->id / 2 == 21;
	return ($u->name, blah => $u->id);
}

sub funcall {
	my $u : users;
	lower($u->name) eq "hehe";
	return ($u->name, blah => $u->id);
}

sub loneterm1 {
	my $u : users;
	$u->boolvar;
}

sub loneterm2 {
	my $u : users;
	!$u->boolvar;
}

sub loneterm3 {
	my $u : users;
	is_digit($u->id);
}

sub funcall2 {
	my $u : users;
	longfunc($u->name eq "hehe", !$u->boolvar);
}

sub funcall3 {
	my $u : users;
	longfunc($u->name eq "hehe", !$u->boolvar) == 42;
}

sub funcall4 {
	my $u : users;
	lc $u->name eq "hehe";
}

sub outer_ref {
	my $g : groups;
	$g->id <- db_fetch {
		my $u : users;
		$g->name eq $u->gname;
		return ($u->gid);
	};
}

sub outer_ref_exists {
	my $g : groups;
	db_fetch {
		my $u : users;
		$g->name eq $u->gname;
	};
}

sub labels {
	my $u : users;
	order_by: $u->name;
};

sub labels2 {
	my $u : users;
	order_by: $u->lastname, $u->firstname;
};

sub labels3 {
	my $u : users;
	LIMIT: 5;
};

my $off = 42;
sub labels4 {
	my $u : users;
	OFFSET: $off;
};

sub retall {
	my $t1 : table1;
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};

my $vart = 'table1';
my $self = { table => 'table1', id => 42, col => 'col1',
	h1 => { h2 => { h3 => 42 }},
};
my %self = ( table => 'table1', id => 42, col => 'col1',
	h1 => { h2 => { h3 => 42 }},
);
sub vartable {
	table: my $t1 = $vart;
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};
sub vartable1 {
	table: my $t1 = $self{table};
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};
sub vartable2 {
	table: my $t1 = $self->{table};
	my $t2 : table2;
	$t1->id == $t2->table1_id;
	return $t1, $t2->name;
};

sub hashref1 {
	my $t : table1;
	$t->id == $self->{id};
};
sub hashref2 {
	my $t : table1;
	$t->id == $self{id};
};
sub hashref3 {
	my $t : table1;
	$t->id == $self{h1}{h2}{h3};
};

sub funnytable {
	my $t : table = $self->{table};
};

sub shouldfail {
	table: $vart = 52;
};

my $type = "hello"; $type = "";
sub parsetime_if {
	my $t : product;
	$t->name eq $type if $type;
};

my $id = 42;
sub return_expr {
	my $p : product_tree;
	my $e : product_eda_adsl;
	$p->id == $id;
	$p->id == $e->id;

	return (
		$p->id,
		$p->circuit_number,
		$e,
		DAYS_TO_ACTIVATION => $e->ACTIVATION_DATE_START-sysdate(),
		TNIDInstallDate => abs($e->selt_date),
	);
};

sub funcall_no_args { tab->id == sysdate() };

sub verbatim {
	tab->id == sql "some_seq.nextval";
};

sub verbatim2 {
	tab->id == `some_seq.nextval`;
};

sub ret_concat {
	return "foo-" . tab->name . "-moo";
};

sub interp {
	my $t : tab;
	return "foo-$t->name-moo";
};

sub funny_interp {
	my $t : tab;
	return "foo-" . $t->firstname . " $t->lastname-moo";
};

sub interp_ashash {
	my $t : tab;
	return "abc$t->{name}xyz";
};

sub null1 {
	!defined(tab->field);
};

my @ary = (1,2,3);
my $ary = [1,2,3];
sub is1 {
	!tab->id  <-  @$ary;
};

# does not work
sub is2 {
	!tab->id  <-  map { $_*2 } @ary;
};

my $two = 2;
sub is3 {
	!tab->id  <-  [1,$two,3];
};

sub autogroup {
	my $t : tab;
	return $t->name, $t->type, count($t->age);
};

my $x = undef;
sub null_comp {
	tab->age != $x;
};

sub re22 {
	tab->str =~ /^$self->{id}/;
};

sub jj {
	my $t : tbl;
	db_fetch { $t->id == t2->some_id };
};

my $col = 'blah';
sub varcol {
	tbl->$col == 42;
};

sub bad1 {
	$self = { x => 1, y => 2};
};

sub re_in {
	tbl->id =~ /^$col/;
};

sub badupd {
	tbl->id == 42;
};

use Time::HiRes qw(time);
sub timeupd {
	tbl->updated = time;
};

sub plusplus {
	tbl->updated += $self->{id} + 2;
};

sub order1 {
	my $m : measurements;
	$m->duration eq 'month'; order_by: $m->period("desc"), $m->f2;
	return $m->period;
}

my $h = { col1 => 42, col2 => 666 };
my %h = ( col1 => 42, col2 => 666 );
sub upd1 {
	my $m : tabname;
 	$m = {%h};
}

sub retvar
{
	my $t : table = $self->{table};
	return $t->$val;
}

sub prior
{
	my $t : xxx;
	$t->id == 42;
	$t->a == `connect by prior`;
}

sub table_as_select_simple
{
	my $a : tab1;
	my $b : table = db_fetch {
		my $c : tab2;
	};
}

sub table_as_select
{
	my $a : tab1;
	my $b : table = db_fetch {
		my $c : tab2;
		my $d : tab3;

		$c->x == $d->y;
		return $c->i, $d->j;
	};
	$b->i == $a->j;
	return $a->n, $b->j;
}

sub str
{
	my $a : tab;
	$a->y == "hello";
	return $a, constant => "Constant";
}

$x = 1;
sub cond
{
	my $a : tab;
	$a->x == 42 or $a->y == 50 unless $x;
	return $a->a, $a->x if $x;
	return $a->a, $a->nox unless $x;
}

sub order
{
	my $a : tab;
	sort $a->src, desc => $a->dst;
	return $a->id;
}

sub seq_x
{
	return next 'hardware_id_seq';
}

my $tabname = "blah";
sub func_in
{
	my $t : tab;
	$t->x <- pt_forward($id);
}

our $VRF_ID = 42;
sub baah
{
	vrf->ID == $VRF_ID; return vrf->NAME
}

DBIx::Perlish::quirk(oracle => table_func_cast => "pt_forward" => "single_number_table");

my ($sql, $v) = DBIx::Perlish::gen_sql(\&s1, "select", flavor => 'oracle');

print "$sql\n";
print "values: ", join ", ", @$v;
print "\n";
